#!/usr/bin/env node

import chalk from "chalk";
import ora from "ora";
import { existsSync, unlinkSync } from "fs";
import { resolve, join, basename, extname } from "path";
import { PromptManager } from "../src/prompts/PromptManager.js";
import { ConverterFactory } from "../src/converters/ConverterFactory.js";
import { detectGPU, getVideoEncoder } from "../src/utils/gpuUtils.js";
import { getFiles, ensureDirectory } from "../src/utils/fileUtils.js";
import {
  getQualitySettings,
  getConcurrencyLevel,
} from "../src/prompts/ConfigurationBuilder.js";
import type { ImageConfig, VideoConfig } from "../src/config/types.js";

// Î™ÖÎ†πÌñâ Ïù∏Ïûê ÌååÏã±
function parseArgs(): {
  inputPath?: string;
  help: boolean;
  version: boolean;
  quick: boolean;
  type?: "image" | "video";
  output?: string;
  quality?: "high" | "medium" | "low";
  format?: string;
  concurrency?: number | "maximum" | "balanced" | "light";
  select?: "all" | string;
} {
  const args = process.argv.slice(2);
  const result = {
    inputPath: undefined as string | undefined,
    help: false,
    version: false,
    quick: false,
  };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];

    if (arg === "--help" || arg === "-h") {
      result.help = true;
    } else if (arg === "--version" || arg === "-v") {
      result.version = true;
    } else if (arg === "--quick") {
      (result as any).quick = true;
    } else if (arg === "--type") {
      const val = args[++i];
      if (val === "image" || val === "video") (result as any).type = val;
    } else if (arg === "--output") {
      (result as any).output = resolve(args[++i]);
    } else if (arg === "--quality") {
      const val = args[++i] as any;
      if (["high", "medium", "low"].includes(val))
        (result as any).quality = val;
    } else if (arg === "--format") {
      (result as any).format = args[++i];
    } else if (arg === "--concurrency") {
      const val = args[++i];
      if (["maximum", "balanced", "light"].includes(val)) {
        (result as any).concurrency = val as any;
      } else {
        const n = parseInt(val);
        if (!Number.isNaN(n) && n > 0) (result as any).concurrency = n;
      }
    } else if (arg === "--select") {
      (result as any).select = args[++i];
    } else if (!arg.startsWith("-") && !result.inputPath) {
      result.inputPath = resolve(arg);
    }
  }

  return result;
}

// ÎèÑÏõÄÎßê Ï∂úÎ†•
function showHelp(): void {
  console.log(chalk.bold.cyan("\nüé® Media to Web CLI\n"));
  console.log(chalk.bold("Usage:"));
  console.log("  npx mtw [input-path] [options]");
  console.log("  npx mtw --help");
  console.log("  npx mtw --version");
  console.log();
  console.log(chalk.bold("Arguments:"));
  console.log("  input-path    Path to input folder containing media files");
  console.log();
  console.log(chalk.bold("Options:"));
  console.log("  -h, --help    Show this help message");
  console.log("  -v, --version Show version number");
  console.log();
  console.log(chalk.bold("Examples:"));
  console.log(
    "  npx mtw /path/to/images     # Interactive mode with pre-selected folder"
  );
  console.log("  npx mtw /Users/username/Desktop/photos");
  console.log("  npx mtw                    # Interactive mode");
  console.log();
  console.log(chalk.bold("Interactive Mode:"));
  console.log(
    "  The CLI always runs in interactive mode where you can configure"
  );
  console.log(
    "  settings step by step. If a path is provided, it will be used as"
  );
  console.log(
    "  the default input folder, but you can still change it during setup."
  );
  console.log();
}

// Î≤ÑÏ†Ñ Ï∂úÎ†•
async function showVersion(): Promise<void> {
  try {
    const packageJson = await import("../package.json", {
      with: { type: "json" },
    });
    console.log(packageJson.default.version);
  } catch (error) {
    console.log("0.0.1");
  }
}

// ÏûÖÎ†• Í≤ΩÎ°ú Í≤ÄÏ¶ù
function validateInputPath(inputPath: string): boolean {
  if (!existsSync(inputPath)) {
    console.error(chalk.red(`‚ùå Error: Path does not exist: ${inputPath}`));
    return false;
  }

  return true;
}

// Ìè¥Îçî ÌÉêÏÉâ Î∞è ÏÑ†ÌÉù Í∏∞Îä•ÏùÄ Ïù¥Ï†ú FolderBrowserPrompt ÌÅ¥ÎûòÏä§Î°ú Ïù¥ÎèôÎê®

console.log(chalk.bold.cyan("\nüé® Media to Web CLI\n"));

// Ï§ëÎã® Ïãú Ï†ïÎ¶¨Ìï† ÌååÏùºÎì§ÏùÑ Ï∂îÏ†Å
let convertedFiles: string[] = [];
let outputFolder: string = "";

// Ctrl+C Ï≤òÎ¶¨
process.on("SIGINT", () => {
  console.log(chalk.yellow("\n\n‚ö†Ô∏è  Conversion interrupted by user"));

  if (convertedFiles.length > 0) {
    console.log(
      chalk.yellow(`Found ${convertedFiles.length} converted files:`)
    );
    convertedFiles.forEach((file) => {
      console.log(chalk.gray(`  - ${file}`));
    });

    console.log(
      chalk.yellow("\nDo you want to keep the converted files? (y/N)")
    );
    process.stdin.setRawMode(true);
    process.stdin.resume();
    process.stdin.on("data", (data) => {
      const key = data.toString();
      if (key === "y" || key === "Y") {
        console.log(chalk.green("‚úì Keeping converted files"));
        process.exit(0);
      } else {
        console.log(chalk.red("üóëÔ∏è  Cleaning up converted files..."));
        convertedFiles.forEach((file) => {
          try {
            if (existsSync(file)) {
              unlinkSync(file);
              console.log(chalk.gray(`  Deleted: ${file}`));
            }
          } catch (error) {
            console.log(chalk.red(`  Failed to delete: ${file}`));
          }
        });
        console.log(chalk.green("‚úì Cleanup completed"));
        process.exit(0);
      }
    });
  } else {
    console.log(chalk.gray("No converted files to clean up"));
    process.exit(0);
  }
});

async function main(): Promise<void> {
  try {
    const args = parseArgs();

    // ÎèÑÏõÄÎßê Ï∂úÎ†•
    if (args.help) {
      showHelp();
      return;
    }

    // Î≤ÑÏ†Ñ Ï∂úÎ†•
    if (args.version) {
      await showVersion();
      return;
    }

    let inputFolder: string;

    // Î™ÖÎ†πÌñâ Ïù∏ÏûêÎ°ú ÏûÖÎ†• Í≤ΩÎ°úÍ∞Ä Ï†úÍ≥µÎêú Í≤ΩÏö∞
    if (args.inputPath) {
      if (!validateInputPath(args.inputPath)) {
        process.exit(1);
      }
      inputFolder = args.inputPath;
      console.log(chalk.gray(`Input folder: ${inputFolder}`));
      console.log(
        chalk.gray(
          "Starting interactive mode with pre-selected input folder...\n"
        )
      );
    } else {
      // Ìè¥Îçî ÏÑ†ÌÉù
      const folderBrowser = new (
        await import("../src/prompts/FolderBrowserPrompt.js")
      ).FolderBrowserPrompt();
      inputFolder = await folderBrowser.selectInputFolder();
      console.log(chalk.gray(`Selected input folder: ${inputFolder}\n`));
    }

    // Quick CLI Î™®Îìú Ï≤òÎ¶¨: ÌîåÎûòÍ∑∏Î°ú Ï¶âÏãú Ïã§Ìñâ
    let config: any;
    if ((args as any).quick) {
      const convertType = ((args as any).type as "image" | "video") || "image";
      const output = (args as any).output || join(inputFolder, "converted");
      ensureDirectory(output);

      // ÌååÏùº ÏÑ†ÌÉù
      let selectedFiles: string[] | null = null;
      if ((args as any).select && (args as any).select !== "all") {
        // Í∞ÑÎã®Ìïú Ìå®ÌÑ¥ Ï≤òÎ¶¨: ÌôïÏû•Ïûê ÌïÑÌÑ∞
        const pattern = (args as any).select as string;
        const ext = extname(pattern).toLowerCase();
        const exts =
          convertType === "image"
            ? [".jpg", ".jpeg", ".png"]
            : [".mp4", ".mov", ".avi", ".mkv"];
        selectedFiles = getFiles(inputFolder, exts).filter((f) =>
          ext ? extname(f).toLowerCase() === ext : true
        );
      } else {
        const exts =
          convertType === "image"
            ? [".jpg", ".jpeg", ".png"]
            : [".mp4", ".mov", ".avi", ".mkv"];
        selectedFiles = getFiles(inputFolder, exts);
      }

      const mode = "quick";
      const quality = (args as any).quality || "high";
      const advancedConfig = undefined;
      const concurrency = (args as any).concurrency || "balanced";

      config = {
        convertType,
        inputFolder,
        selectedFiles,
        outputFolder: output,
        quality,
        mode,
        advancedConfig,
        concurrency,
      };
    } else {
      // Í∏∞Ï°¥ ÎåÄÌôîÏãù ÌùêÎ¶Ñ
      const promptManager = new PromptManager();
      config = await promptManager.promptUser(inputFolder);
    }

    // Ï∂úÎ†• Ìè¥Îçî Ï†ÄÏû• (Ï†ïÎ¶¨Ïö©)
    outputFolder = config.outputFolder;

    const qualitySettings = getQualitySettings(
      config.quality,
      config.convertType as "image" | "video",
      config.advancedConfig
    );

    console.log(chalk.gray("\nConfiguration:"));
    console.log(
      chalk.gray(
        `  Convert type: ${
          config.convertType === "image" ? "Images" : "Videos"
        }`
      )
    );
    console.log(
      chalk.gray(`  Mode: ${config.mode === "simple" ? "Simple" : "Advanced"}`)
    );
    console.log(chalk.gray(`  Selected files: ${config.selectedFiles.length}`));
    console.log(chalk.gray(`  Input folder: ${config.inputFolder}`));
    console.log(chalk.gray(`  Output folder: ${config.outputFolder}`));

    // CPU ÏÇ¨Ïö©Î•† ÏÑ§Ï†ï ÌëúÏãú
    const actualConcurrency = getConcurrencyLevel(
      config.concurrency as number | "maximum" | "balanced" | "light",
      config.convertType as "image" | "video"
    );
    console.log(
      chalk.gray(
        `  CPU usage: ${config.concurrency} (${actualConcurrency} concurrent processes)`
      )
    );

    if (config.mode === "simple") {
      console.log(chalk.gray(`  Quality: ${config.quality}`));
    } else {
      // Í≥†Í∏â Î™®Îìú ÏÑ§Ï†ï ÌëúÏãú
      if (config.convertType === "image") {
        const imageSettings = qualitySettings as ImageConfig;
        console.log(chalk.gray(`  Image quality: ${imageSettings.quality}`));
        console.log(
          chalk.gray(`  Format: ${imageSettings.format.toUpperCase()}`)
        );
      } else {
        const videoSettings = qualitySettings as VideoConfig;
        console.log(chalk.gray(`  CRF: ${videoSettings.crf}`));
        console.log(chalk.gray(`  Preset: ${videoSettings.preset}`));
        console.log(chalk.gray(`  Codec: ${videoSettings.codec}`));
      }
    }
    console.log();

    // GPU Í∞êÏßÄ Î∞è ÌïòÎìúÏõ®Ïñ¥ Í∞ÄÏÜç ÏÑ§Ï†ï
    let gpuInfo = null;
    let videoEncoder = null;

    if (config.convertType === "video") {
      gpuInfo = detectGPU();
      videoEncoder = getVideoEncoder(gpuInfo, qualitySettings as VideoConfig);

      // GPU ÏÉÅÌÉú ÌëúÏãú
      if (gpuInfo.available) {
        console.log(
          chalk.green(
            `‚úì ${gpuInfo.type.toUpperCase()} GPU detected - Hardware acceleration enabled`
          )
        );
        console.log(chalk.gray(`  Using encoder: ${videoEncoder.codec}`));
      } else {
        console.log(chalk.gray("‚Ñπ No GPU detected - Using CPU encoding"));
        console.log(chalk.gray(`  Using encoder: ${videoEncoder.codec}`));
      }
      console.log(); // Îπà Ï§Ñ Ï∂îÍ∞Ä
    }

    // Î≥ÄÌôò ÏãúÏûë ÏãúÍ∞Ñ Í∏∞Î°ù
    const startTime = Date.now();

    // Í∞úÎ≥Ñ ÌååÏùº ÏßÑÌñâÎ•† Ï∂îÏ†ÅÏùÑ ÏúÑÌïú ÏÉÅÌÉú
    const fileProgress = new Map();
    let currentFile = "";
    let spinner = ora("Preparing conversion...").start();

    // ÏßÑÌñâÎ•† ÏΩúÎ∞± Ìï®Ïàò
    const progressCallback = (progressInfo: any) => {
      const { current, total, file, status, progress, error } = progressInfo;

      if (status === "converting") {
        currentFile = file;
        fileProgress.set(file, { status, progress: progress || 0 });

        if (progress !== undefined) {
          // ÎπÑÎîîÏò§ Î≥ÄÌôò Ï§ë - ÌçºÏÑºÌä∏ ÌëúÏãú
          spinner.text = `Converting ${file} (${current}/${total}) - ${progress.toFixed(
            1
          )}%`;
        } else {
          // Ïù¥ÎØ∏ÏßÄ Î≥ÄÌôò Ï§ë - ÌååÏùºÎ™ÖÎßå ÌëúÏãú
          spinner.text = `Converting ${file} (${current}/${total})`;
        }
      } else if (status === "completed") {
        fileProgress.set(file, { status: "completed", progress: 100 });
        spinner.succeed(`‚úì ${file} completed (${current}/${total})`);

        // Î≥ÄÌôòÎêú ÌååÏùº Ï∂îÏ†Å (Ï†ïÎ¶¨Ïö©)
        const outputFile = join(
          outputFolder,
          basename(file, extname(file)) +
            (config.convertType === "image"
              ? ".webp"
              : (qualitySettings as VideoConfig).format === "webm"
              ? ".webm"
              : ".mp4")
        );
        convertedFiles.push(outputFile);

        // Îã§Ïùå ÌååÏùºÏù¥ ÏûàÏúºÎ©¥ ÏÉàÎ°úÏö¥ Ïä§ÌîºÎÑà ÏãúÏûë
        if (current < total) {
          spinner = ora("Preparing next file...").start();
        }
      } else if (status === "failed") {
        fileProgress.set(file, { status: "failed", error });
        spinner.fail(`‚úó ${file} failed: ${error} (${current}/${total})`);

        // Îã§Ïùå ÌååÏùºÏù¥ ÏûàÏúºÎ©¥ ÏÉàÎ°úÏö¥ Ïä§ÌîºÎÑà ÏãúÏûë
        if (current < total) {
          spinner = ora("Preparing next file...").start();
        }
      }
    };

    // ÏÉàÎ°úÏö¥ ConverterFactory ÏÇ¨Ïö©
    const converter = ConverterFactory.createConverter(
      config.convertType as "image" | "video"
    );
    const results = await converter.convert(
      config.inputFolder,
      config.outputFolder,
      qualitySettings,
      config.selectedFiles,
      progressCallback,
      actualConcurrency
    );

    // Î≥ÄÌôò ÏôÑÎ£å ÏãúÍ∞Ñ Í∏∞Î°ù Î∞è ÏÜåÏöîÏãúÍ∞Ñ Í≥ÑÏÇ∞
    const endTime = Date.now();
    const elapsedTime = endTime - startTime;
    const elapsedSeconds = Math.floor(elapsedTime / 1000);
    const elapsedMinutes = Math.floor(elapsedSeconds / 60);
    const remainingSeconds = elapsedSeconds % 60;

    let timeString;
    if (elapsedMinutes > 0) {
      timeString = `${elapsedMinutes}m ${remainingSeconds}s`;
    } else {
      timeString = `${elapsedSeconds}s`;
    }

    // ÎßàÏßÄÎßâ Ïä§ÌîºÎÑà Ï†ïÎ¶¨
    if (spinner.isSpinning) {
      spinner.succeed("Conversion completed!\n");
    } else {
      console.log(chalk.green("\n‚úì Conversion completed!\n"));
    }

    // ÏÑ±Í≥µÌïú Î≥ÄÌôò Í≤∞Í≥º Ï∂úÎ†•
    if (results.success.length > 0) {
      console.log(
        chalk.bold.green(`‚úÖ Success (${results.success.length} files):\n`)
      );
      results.success.forEach((item) => {
        console.log(
          chalk.green(`  ${item.input}`) +
            chalk.gray(" ‚Üí ") +
            chalk.cyan(item.output)
        );
        console.log(
          chalk.gray(`    ${item.inputSize}`) +
            chalk.gray(" ‚Üí ") +
            chalk.blue(item.outputSize) +
            chalk.yellow(` (${item.reduction}% reduction)`)
        );
      });
    }

    // Ïã§Ìå®Ìïú Î≥ÄÌôò Í≤∞Í≥º Ï∂úÎ†•
    if (results.failed.length > 0) {
      console.log(
        chalk.bold.red(`\n‚ùå Failed (${results.failed.length} files):\n`)
      );
      results.failed.forEach((item) => {
        console.log(chalk.red(`  ${item.file}: ${item.error}`));
      });
    }

    console.log(chalk.gray(`\nOutput folder: ${config.outputFolder}`));
    console.log(chalk.gray(`Total elapsed time: ${timeString}\n`));
  } catch (error: any) {
    console.error(chalk.red("\n‚ùå Error occurred:"), error.message);
    process.exit(1);
  }
}

main();
